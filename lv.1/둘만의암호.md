### 풀이 방식
    1. s의 각 문자(ss)를 이동하기 위해 반복문 실행

    2. 실제 이동 값(count)와 index(목표 이동 값)이 같을 때까지 반복문 실행
        2-1. ss의 ASCII 값(ss_ascii) 확인
        2-2. ss_ascii 값에 1을 더하여, ss의 다음 문자가 z를 넘어가는지 검사
            (1) z를 넘어갈 경우, 연산을 통해 초과된 값만큼 a부터 순서를 재정렬 후 return
            (2) z를 넘어가지 않은 경우, 1을 더한 값을 그대로 return
        2-3. 검사를 마친 ss_ascii의 string 값이 skip 문자열에 포함되는지 검사
            (1) 포함될 경우, 별도의 작업 없이 다음 loop 진행
            (2) 포함되지 않을 경우, count 값을 증가시키고 다음 loop 진행
    
    3. skip 문자를 제외하고 이동을 마친 문자를 answer 문자열에 추가
    
    4. s의 모든 문자를 이동시킨 answer를 return


### 회고
    - s에 같은 문자가 다수 있을 경우, 결과값을 저장해두고 반복 문자 차례에 사용하면 시간 복잡도를 줄일 수 있었다.
      이는 알고리즘 풀이에 많이 사용되는 방법이라고 한다. (thanks to kkh 🙌)
    - 전체 알파벳을 저장하고 skip 문자를 제거하면 훨씬 간단한 코드가 완성된다!
      소거법을 생각하지 못한 건 너무 아쉬운 일이지만, 이제라도 알았으니 앞으론 열심히 써먹어야지 🤦‍♀️

### 메모
    - ASCII 값 변환
        - ord(문자) : 문자 -> ASCII
        - chr(정수) : ASCII -> 문자
